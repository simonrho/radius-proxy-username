#!/usr/bin/env python

import argparse
import signal
import re
import sys
import time
import logging
import logging.handlers
import hashlib
import socket
from threading import *
from struct import *

try:
    import socketserver
except ImportError:
    import SocketServer as socketserver

__version__ = '1.0.1'
__author__ = 'Simon Rho'

PYV = sys.version_info.major
PYV_FULL = '{}.{}.{}'.format(sys.version_info.major, sys.version_info.minor, sys.version_info.micro)

RADIUS_CODE_ACCESS_REQUEST = 1
RADIUS_CODE_ACCESS_ACCEPT = 2
RADIUS_CODE_ACCESS_REJECT = 3
RADIUS_CODE_ACCOUNTING_REQUEST = 4
RADIUS_CODE_ACCOUNTING_RESPONSE = 5
RADIUS_CODE_ACCESS_CHALLENGE = 11

RADIUS_AVP_USERNAME = 1
RADIUS_AVP_FRAMED_ROUTE = 22
RADIUS_AVP_VENDOR_SPECIFIC = 26

RADIUS_BBF_VENDOR_ID = 3561
RADIUS_JUNIPER_VENDOR_ID = 4874

RADIUS_AVP_JUNIPER_PPPOE_DESCRIPTION = 24
RADIUS_AVP_JUNIPER_DHCP_OPTIONS = 55
RADIUS_AVP_JUNIPER_DHCP_MAC_ADDRESS = 56

radius_code_name_table = [
    '',
    'access-request     ',
    'access-accept      ',
    'access-reject      ',
    'accounting-request ',
    'accounting-response',
    '',
    '',
    '',
    '',
    '',
    'access-challenge   '
]


def BYTES(value):
    if PYV == 2:
        return value

    return bytes(value, 'utf-8')

def STR(value):
    if PYV == 2:
        return value

    return value.decode('utf-8')

def ORD(value):
    if PYV == 2:
        return ord(value)

    return value

def background(func):
    def bg_func(*args, **kwargs):
        t = Thread(target=func, args=args, kwargs=kwargs)
        t.setDaemon(True)
        t.start()

    return bg_func


class Logging:
    """
    For logging support, the default logging file is /var/log/jrp.log and 100MB size with three rotate files.
    """

    def __init__(self, filename):
        self.filename = filename
        self.filesize = 100000000
        self.rotate_files = 3
        self.severity = 'DEBUG'
        self.logger = logging.getLogger(filename)

        formatter = logging.Formatter(fmt='%(asctime)s.%(msecs)03d %(levelname)s %(lineno)d: %(message)s',
                                      datefmt='%Y-%m-%d %H:%M:%S')

        fileh = logging.handlers.RotatingFileHandler(self.filename, maxBytes=self.filesize,
                                                     backupCount=self.rotate_files)
        fileh.setFormatter(formatter)
        fileh.set_name('file')
        self.logger.addHandler(fileh)

        ch = logging.StreamHandler(sys.stdout)
        ch.setFormatter(formatter)
        self.logger.addHandler(ch)

        self.logger.setLevel(self.severity)


LOG = Logging('/var/log/jrp.log')


class JunosDecrypt:
    """
    For decrypting radius secret key value generated by Junos system.
    The secret key starting with $9$ is going to be decrypted and presented as a plain-text
    """
    MAGIC = "$9$"
    MAGIC_SEARCH = "\$9\$"
    FAMILY = ['QzF3n6/9CAtpu0O', 'B1IREhcSyrleKvMW8LXx', '7N-dVbwsY2g4oaJZGUDj', 'iHkq.mPf5T']
    EXTRA = {}
    VALID = ""
    NUM_ALPHA = ""
    ALPHA_NUM = {}
    ENCODING = [[1, 4, 32], [1, 16, 32], [1, 8, 32], [1, 64], [1, 32], [1, 4, 16, 128], [1, 32, 64]]

    def __init__(self):
        for fam in range(len(self.FAMILY)):
            for c in range(len(self.FAMILY[fam])):
                token = self.FAMILY[fam]
                self.EXTRA[token[c]] = (3 - fam)

        self.NUM_ALPHA = ''.join(self.FAMILY)
        self.VALID = "[" + self.MAGIC + self.NUM_ALPHA + "]"

        for num_alpha in range(len(self.NUM_ALPHA)):
            self.ALPHA_NUM[self.NUM_ALPHA[num_alpha]] = num_alpha

    def _nibble(self, cref, length):
        nib = cref[0:length]
        cref = cref[length:]

        return nib, cref

    def _gap(self, c1, c2):
        return ((self.ALPHA_NUM[c2] - self.ALPHA_NUM[c1]) % len(self.NUM_ALPHA)) - 1

    def _gap_decode(self, gaps, dec):
        num = 0
        if len(gaps) != len(dec):
            return None
        else:
            for i in range(len(gaps)):
                num += gaps[i] * dec[i]

        return chr(num % 256)

    def decrypt(self, crypt):
        if (crypt == None or len(crypt) == 0):
            print("Invalid Crypt")
            return None

        valid_chars = re.compile(self.VALID)
        if (valid_chars.match(crypt) != None):
            match_object = re.match(self.MAGIC_SEARCH, crypt)
            chars = crypt[match_object.end():]
            first, chars = self._nibble(chars, 1)
            var, chars = self._nibble(chars, self.EXTRA[first])
            prev = first
            decrypt_str = ''

            while len(chars) > 0:
                decode = self.ENCODING[len(decrypt_str) % len(self.ENCODING)]
                length = len(decode)
                nibble, chars = self._nibble(chars, length)
                gaps = []
                for i in range(len(nibble)):
                    gaps.append(self._gap(prev, nibble[i]))
                    prev = nibble[i]

                decrypt_str += self._gap_decode(gaps, decode)

            return decrypt_str
        else:
            print(crypt + " is invalid !!")


def dissect(attributes):
    spec = {}

    i = 0
    data_length = len(attributes)
    while i < data_length:
        avp_type = ORD(attributes[i])
        avp_length = ORD(attributes[i + 1])
        avp_value = attributes[i + 2:i + avp_length]
        if avp_type == RADIUS_AVP_VENDOR_SPECIFIC:
            vendor_id = unpack('>I', avp_value[0:4])[0]
            j = 4
            vsa_data_length = len(avp_value)
            while j < vsa_data_length:
                vsa_type = ORD(avp_value[j])
                vsa_length = ORD(avp_value[j + 1])
                vsa_value = avp_value[j + 2:j + vsa_length]
                if (vendor_id, vsa_type) in spec:
                    spec[(vendor_id, vsa_type)].append(vsa_value)
                else:
                    spec[(vendor_id, vsa_type)] = [vsa_value]
                j += vsa_length
        else:
            if (0, avp_type) in spec:
                spec[(0, avp_type)].append(avp_value)
            else:
                spec[(0, avp_type)] = [avp_value]

        i += avp_length

    return spec


def assemble(spec):
    data = b''
    bbf_vsa_data = b''
    for (vendor_id, avp_type) in spec:
        avp_value = spec[(vendor_id, avp_type)]
        if vendor_id == 0:
            for v in avp_value:
                data += pack('>BB{}s'.format(len(v)), avp_type, len(v) + 2, v)
        elif vendor_id == RADIUS_JUNIPER_VENDOR_ID:
            for v in avp_value:
                data += pack('>BBIBB{}s'.format(len(v)), RADIUS_AVP_VENDOR_SPECIFIC, len(v) + 8,
                             RADIUS_JUNIPER_VENDOR_ID, avp_type, len(v) + 2, v)
        elif vendor_id == RADIUS_BBF_VENDOR_ID:
            for v in avp_value:
                bbf_vsa_data += pack('>BB{}s'.format(len(v)), avp_type, len(v) + 2, v)

    if len(bbf_vsa_data) > 0:
        data += pack('>BB', RADIUS_AVP_VENDOR_SPECIFIC, len(bbf_vsa_data) + 6) + \
                pack('>I', RADIUS_BBF_VENDOR_ID) + bbf_vsa_data

    return data


def avp_create(spec, vendor_id, avp, value):
    if type(value) == str:
        value = BYTES(value)

    if (vendor_id, avp) not in spec:
        spec[(vendor_id, avp)] = [value]
        return spec[(vendor_id, avp)]
    return None


def avp_get(spec, vendor_id, avp, to_string=False):
    if (vendor_id, avp) in spec:
        if to_string:
            return STR(spec[(vendor_id, avp)][0])
        return spec[(vendor_id, avp)]
    return None


def avp_set(spec, vendor_id, avp, value):
    if type(value) == str:
        value = BYTES(value)

    if (vendor_id, avp) in spec:
        spec[(vendor_id, avp)] = [value]
        return spec[(vendor_id, avp)]
    return None


def avp_append(spec, vendor_id, avp, value):
    if type(value) == str:
        value = BYTES(value)

    if (vendor_id, avp) in spec:
        spec[(vendor_id, avp)].append(value)
        return spec[(vendor_id, avp)]
    else:
        spec[(vendor_id, avp)] = [value]

    return spec[(vendor_id, avp)]


def avp_delete(spec, vendor_id, avp):
    if (vendor_id, avp) in spec:
        del spec[(vendor_id, avp)]


def calculate_authenticator(data, authenticator_from_client, secret):
    code, index, length = unpack('>BBH', data[0:4])

    if code == RADIUS_CODE_ACCESS_REQUEST:
        return data[4:20]

    if code == RADIUS_CODE_ACCESS_ACCEPT:
        d = pack('>BBH', code, index, length) + authenticator_from_client + data[20:] + BYTES(secret)
        m = hashlib.md5()
        m.update(d)
        new_authenticator = m.digest()
        return new_authenticator

    if code == RADIUS_CODE_ACCESS_REJECT:
        return data[4:20]

    if code == RADIUS_CODE_ACCESS_CHALLENGE:
        return data[4:20]

    if code == RADIUS_CODE_ACCOUNTING_REQUEST:
        d = pack('>BBH', code, index, length) + 16 * b'\x00' + data[20:] + BYTES(secret)
        m = hashlib.md5()
        m.update(d)
        new_authenticator = m.digest()
        return new_authenticator

    if code == RADIUS_CODE_ACCOUNTING_RESPONSE:
        d = pack('>BBH', code, index, length) + authenticator_from_client + data[20:] + BYTES(secret)
        m = hashlib.md5()
        m.update(d)
        new_authenticator = m.digest()

        return new_authenticator


def convert_mac_format(mac):
    return mac[0:2] + ':' + mac[2:4] + ':' + mac[5:7] + ':' + mac[7:9] + ':' + mac[10:12] + ':' + mac[12:14]


class ThreadedRadiusProxyServerHandler(socketserver.BaseRequestHandler):
    """
    Incoming radius message handler
    """

    def handle(self):
        data = self.request[0]
        local_sock = self.request[1]
        secret = self.server.secret

        code, index, length, authenticator_from_client = unpack('>BBH16s', data[0:20])
        attributes = data[20:]

        spec = dissect(attributes)

        mac_address = avp_get(spec, RADIUS_JUNIPER_VENDOR_ID, RADIUS_AVP_JUNIPER_DHCP_MAC_ADDRESS, to_string=True)
        if mac_address is not None:
            mac_address2 = convert_mac_format(mac_address)

            is_dhcp_session = True if avp_get(spec, RADIUS_JUNIPER_VENDOR_ID, RADIUS_AVP_JUNIPER_DHCP_OPTIONS) else False
            session_type = 'dhcp-session' if is_dhcp_session else 'pppoe-session'

            if is_dhcp_session:
                avp_set(spec, 0, RADIUS_AVP_USERNAME, mac_address2)
                avp_set(spec, RADIUS_JUNIPER_VENDOR_ID, RADIUS_AVP_JUNIPER_DHCP_MAC_ADDRESS, mac_address2)
                avp_set(spec, RADIUS_JUNIPER_VENDOR_ID, RADIUS_AVP_JUNIPER_PPPOE_DESCRIPTION, mac_address2)
                LOG.logger.debug(
                    '{} id: {} dhcp-session: "{}" -> "{}"'.format(radius_code_name_table[code], index, mac_address,
                                                                  mac_address2))
            else:
                avp_set(spec, RADIUS_JUNIPER_VENDOR_ID, RADIUS_AVP_JUNIPER_DHCP_MAC_ADDRESS, mac_address2)
                avp_set(spec, RADIUS_JUNIPER_VENDOR_ID, RADIUS_AVP_JUNIPER_PPPOE_DESCRIPTION, mac_address2)
                LOG.logger.debug(
                    '{} id: {} pppoe-session: "{}" -> "{}"'.format(radius_code_name_table[code], index, mac_address,
                                                                   mac_address2))

        attributes2 = assemble(spec)
        data2 = pack('>BBH16s', code, index, len(attributes2) + 20, authenticator_from_client) + attributes2
        authenticator2 = calculate_authenticator(data2, authenticator_from_client, secret)
        data2 = data2[0:4] + authenticator2 + data2[20:]

        try:
            remote_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            remote_sock.bind((self.server.local[0], 0))
            remote_sock.connect(self.server.remote)
            remote_sock.settimeout(self.server.timeout)
            remote_sock.sendall(data2)

            response = remote_sock.recv(2000)

            r_authenticator = calculate_authenticator(response, authenticator_from_client, secret)
            r_data2 = response[0:4] + r_authenticator + response[20:]

            local_sock.sendto(r_data2, self.client_address)

        except socket.timeout:
            LOG.logger.error('socket timeout: {}'.format(self.server.remote))
            return

        except Exception as e:
            LOG.logger.error('socket error: {}'.format(e))

        finally:
            remote_sock.close()


class ThreadedRadiusProxyServer(socketserver.ThreadingMixIn, socketserver.UDPServer):
    pass


class JSignal:
    """
    OS signal handler capturing OS signals - HUP, TERM, INT - to run run extra actions before exit.
    """

    def __init__(self):
        signal.signal(signal.SIGHUP, self.signal_handler)
        signal.signal(signal.SIGTERM, self.signal_handler)
        signal.signal(signal.SIGINT, self.signal_handler)

    def signal_handler(self, signal, frame):
        LOG.logger.debug('catch signal: SIGINT({})'.format(signal))
        LOG.logger.info("**************")
        LOG.logger.info('stop and exit.')
        LOG.logger.info("**************")
        print('stop and exit.')
        sys.exit(0)


def main():
    """
    main function starting the radius proxy application
    """
    print('radius proxy starts!!!')
    LOG.logger.info("**********************")
    LOG.logger.info("radius proxy starts!!!")
    LOG.logger.info("**********************")
    LOG.logger.info('python version: {}'.format(PYV_FULL))
    LOG.logger.debug('arguments: {}'.format(sys.argv))

    parser = argparse.ArgumentParser(description='radius proxy converting mac username in xx:xx:xx:xx:xx:xx format.')
    parser.add_argument('-m', '--m', type=str, required=True, help='<local ip>:<port>-<remote ip>:<port>-<secret> ...')
    parser.add_argument('-t', '--t', type=int, default=3, help='timeout (sec) - default 3 seconds')
    args = parser.parse_args()

    JSignal()
    JD = JunosDecrypt()

    for m in args.m.split(','):
        local, remote, radius_secret = m.split('-', 2)
        local_ip, local_port = local.split(':')
        remote_ip, remote_port = remote.split(':')

        local_port = int(local_port)
        remote_port = int(remote_port)

        LOG.logger.debug(
            'proxy mapping: {}:{} <==> {}:{} : {}'.format(local_ip, local_port, remote_ip, remote_port, radius_secret))

        if radius_secret[0:3] == '$9$':
            radius_secret = JD.decrypt(radius_secret)

        radius_server = ThreadedRadiusProxyServer((local_ip, local_port), ThreadedRadiusProxyServerHandler)
        radius_server.local = (local_ip, local_port)
        radius_server.remote = (remote_ip, remote_port)
        radius_server.secret = radius_secret
        radius_server.timeout = args.t
        radius_accounting_server_thread = Thread(target=radius_server.serve_forever)
        radius_accounting_server_thread.setDaemon(True)
        radius_accounting_server_thread.start()

    while True:
        time.sleep(1)


if __name__ == '__main__':
    main()
